#include "imports/stdlib.fc";

global int admin_pubkey;
global int available;
global int price;
global slice sender;

const int op::purchase = 0x4c56b6b5;

const int const::fees = 50000000;

const int error::invalid_signature = 701;
const int error::wrong_sender = 702;
const int error::not_enough_value = 703;

() load_data() impure {
    slice ds = get_data().begin_parse();
    admin_pubkey = ds~load_uint(256);
    available = ds~load_uint(32);
    price = ds~load_coins();
}

() save_data() impure {
    set_data(begin_cell()
        .store_uint(admin_pubkey, 256)
        .store_uint(available, 32)
        .store_coins(price)
    .end_cell());
}

() mint(int quantity) impure {
    ;; todo:
    ;; send message to mint NFTs to `sender`
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    sender = cs~load_msg_addr();
    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == op::purchase) {
        slice signature = in_msg_body~load_bits(512);
        throw_unless(error::invalid_signature, check_signature(slice_hash(in_msg_body), signature, admin_pubkey));
        int query_id = in_msg_body~load_uint(64);
        slice user = in_msg_body~load_msg_addr();
        throw_unless(error::wrong_sender, equal_slices(sender, user));

        int quantity = in_msg_body~load_uint(8);
        if (quantity > available) {
            quantity = available;
        }
        throw_unless(error::not_enough_value, (msg_value - const::fees) < (quantity * price));
        available -= quantity;
        
        mint(quantity);

        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender)
            .store_coins(msg_value - const::fees - (quantity * price))
            .store_uint(0, 107)
        .end_cell(), 0);

        save_data();
    }
}
